---
title: 找实习期间的学习记录（下）
date: 2018-12-12 16:16:16
categories: [技术向]
tags: [前端,实习]
---

> 这些是在找实习阶段（2018/03-2018/05）所涉及的复习点
> 有些许杂乱且不完整，勿喷

# HOLD TIGHT


## 什么是 SPA ？

- SPA 的优缺点？

## 什么是 SSR ？

- 为什么要使用SSR？

## 什么是同构？

## HTTPS 与 HTTP 的区别？

- HTTPS 如何加密？
- HTTPS 如何验证证书的有效性？


## HTTP 缓存机制

> [浏览器缓存详解:expires,cache-control,last-modified,etag详细说明  -csdnBlog](https://blog.csdn.net/eroswang/article/details/8302191)


## 伪类 :after 和 ::after 区别

- :after  => CSS2   
- ::after => CSS3	// IE8以下不支持

## DOM操作——怎样添加、移除、移动、复制、创建和查找节点。
1. 创建新节点

> createDocumentFragment() // 创建一个DOM片段
createElement() // 创建一个具体的元素
createTextNode() // 创建一个文本节点

2. 添加、移除、替换、插入

> appendChild()
removeChild()
replaceChild()
insertBefore() // 在已有的子节点前插入一个新的子节点

3. 查找

> getElementsByTagName() // 通过标签名称
getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
getElementById() // 通过元素Id，唯一性


## script 标签， defer 与 async 属性的作用与区别

- async

> 文档加载、渲染 与 js加载执行 是 并行的， 即异步执行

- defer

> 加载后续文档 与 js加载 是异步的，但js执行需要等到文档解析完成之后，即DOMContentLoaded触发执行之前


defer 会按照加载顺序执行， async 会加载完即执行，无序


## html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？

- 新特性：

> HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
> 1. 拖拽释放(Drag and drop) API
> 2. 语义化更好的内容标签（header,nav,footer,aside,article,section）
> 3. 音频、视频API(audio,video)
> 4. 画布(Canvas) API
> 5. 地理(Geolocation) API
> 6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
> 7. sessionStorage 的数据在浏览器关闭后自动删除
> 8. 表单控件，calendar、date、time、email、url、search  
> 9. 新的技术webworker, websocket, Geolocation

- 移除的元素：

> 1. 纯表现的元素：basefont，big，center，font, s，strike，tt，u；
> 2. 对可用性产生负面影响的元素：frame，frameset，noframes；

- 支持HTML5新标签：

> 1. IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）：
```
<!--[if lt IE 9]> 
<script> src="http://html5shiv.googlecode.com/svn/trunk/html5.js"</script> 
<![endif]--> 
```
如何区分： 
DOCTYPE声明新增的结构元素、功能元素

## 居中

- 多种居中方式

> [怎么实现div的水平居中和垂直居中 -CNblogs](https://www.cnblogs.com/haoyijing/p/5760423.html)

## JS Event Loop

> [JavaScript 运行机制详解：再谈Event Loop -阮一峰](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)

## Microtask & Macrotask

> [[译] 深入理解 JavaScript 事件循环（二）— task and microtask  -cnblogs](https://www.cnblogs.com/dong-xu/p/7000139.html)

> [理解 js 事件循环二 (macrotask 和 microtask)  -掘金](https://juejin.im/entry/58332d560ce46300610e4bad)


## Web Workers

> [使用 Web Workers -MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)

> [Javascript 基础夯实 —— 使用 webWorker 实现多线程 -知乎](https://zhuanlan.zhihu.com/p/29219879)

## reflow & repaint

> [[ JS 进阶 ] Repaint 、Reflow 的基本认识和优化 (2)  -segmentfault](https://segmentfault.com/a/1190000002629708)

> [reflow 和 repaint  -segmentfault](https://segmentfault.com/a/1190000006104095)



## drag & drop 事件

> [原生拖拽,拖放事件(drag and drop) -segmentfault](https://segmentfault.com/a/1190000002810962)


## style & currentStyle & getComputedStyle

> [js中style,currentStyle和getComputedStyle的区别以及获取css操作方法  -cnblogs](https://www.cnblogs.com/cythia/p/6721145.html)

## window.requestAnimationFrame

- 理解与使用

## transform、transition、animation

- 可以引申到之前参加的360前端星计划写的2048动画实现（6小时时间完成主体功能，2小时完成动画）

> [css3动画属性详解之transform、transition、animation  -segmentfault](https://segmentfault.com/a/1190000004460780)


## indexedDB

> [HTML5 indexedDB前端本地存储数据库实例教程  -张鑫旭](http://www.zhangxinxu.com/wordpress/2017/07/html5-indexeddb-js-example/)

## 前端所有存储方式 cookie localStorage sessionStorage indexedDB websql

> [前端存储](https://segmentfault.com/a/1190000005927232)


## 事件代理

- 为什么要使用事件代理？

## instanceof & typeof
- 如何区分 number object array string boolean undefined function

## JS事件模型

!important

> [JS事件模型  -segmentfault](https://segmentfault.com/a/1190000006934031)


## 什么是幂等

- 概念理解

## 线程与进程

- 概念 & 区别
- 这里可以引例：以前的Chrome是单进程多线程，崩一个页面即全崩，而现在为多进程单线程，一个页面崩其他页面无事。

## 进程间通信

- 管道pipe
- 命名管道FIFO
- 消息队列messageQueue
- 共享内存sharedMemory
- 信号量semaphore
- 套接字socket
- 信号sinal 

> [进程间通信的方式——信号、管道、消息队列、共享内存  -cnblogs](https://www.cnblogs.com/LUO77/p/5816326.html)



--------

--------

VUE

Vue.js面试总结 https://segmentfault.com/a/1190000014252365 

--------

HTTP

1.0 1.1 2.0 https://segmentfault.com/a/1190000013028798 
https://segmentfault.com/a/1190000008900299 

1.0 2.0 spdy https https://www.cnblogs.com/wjlog/p/5827168.html 

--------

前端总结：

https://www.zybuluo.com/OneS/note/1077112 
https://www.zybuluo.com/OneS/note/1082076 
https://www.zybuluo.com/OneS/note/1078570 
https://github.com/OneMay/front-end 

---------

掘金

https://juejin.im/post/5aa8a07cf265da238a3022a4 
https://juejin.im/post/5abf68886fb9a028b54802e0 
https://juejin.im/post/5abde750f265da238a308e63 

---------

面筋

https://www.nowcoder.com/discuss/72763?type=0&order=0&pos=59&page=1 
http://m.nowcoder.com/discuss/77830 

---------

部分代码实现，仅供自己保存与复习，不接受评价（手动滑稽）
```js
// 对象深复制：
function deepCopy (obj, res = {}) {
  for(let i in obj) {
    if(typeof obj[i] === 'object') {
      res[i] = obj[i].constructor === Array ? [] : {};
      deepCopy(obj[i], res[i]);
    } else {
      res[i] = obj[i];
    }
  }
  return res;
}
// console.log(deepCopy({ a:1, b: [2, 3, { c: 2+3 } ] }))



// 单例模式
let mok = function (name) {
  this.name = 'mok  ' + name;
}
mok.prototype.getName = function () {
  return this.name;
}
mok.getMok = (function () {
  let temp;
  return function (name) {
    if(!temp) {
      return temp = new mok(name);
    } else {
      return temp;
    }
  }
})();
// console.log(mok.getMok('name1') === mok.getMok('xzc'))



// DOM 深广度优先遍历
let res = [];
function bfs(node) {
  let temp = [];
  while(node) {
    res.push(node);
    for(let i=0; i<node.children.length; i++) {
      temp.push(node.children[i]);
    }
    node = temp.shift();
  }
}
function dfs(node) {
  if(!node) return;
  res.push(node);
  for(let i=0; i<node.children.length; i++) {
    dfs(node.children[i])
  }
}



// 模拟 promise
let mPromise = function (fn) {
  this.queue = [];
  this.queue_fail = [];
  this.status = null;
  this.data = null;

  fn(mPromise.resolve.bind(this), mPromise.reject.bind(this));
}
mPromise.resolve = function (data) {
  this.status = 1;
  this.data = data;
  let curr = this.queue.shift();
  if(curr) {
    try {
      let r = curr(data);
      mPromise.resolve.call(this, r instanceof mPromise ? r.data : r );
    } catch (error) {
      mPromise.reject.call(this, error);
    }
  }

}
mPromise.reject = function (data) {
  this.status = 0;
  this.data = data;

  if(this.queue_fail.length > 0) {
    this.queue_fail.pop()(data);
  } else {
    //throw new Error('error');
    console.log(new Error(data));
  }

}
mPromise.prototype.then = function (fn) {
  if(Object.prototype.toString.call(fn) !== '[object Function]') return;

  if(this.status) {
    this.data = fn(this.data);
  } else {
    this.queue.push(fn);
  }
  return this;
}
mPromise.prototype.catch = function (fn) {
  if(Object.prototype.toString.call(fn) !== '[object Function]') return;

  if(this.status) {
    this.queue_fail.push(fn);
  } else {
    this.data = fn(this.data);
  }
  return this;
}
// console.log(new mPromise((res, rej) => { console.log(123); rej('rej') }).then(res => console.log(666)).catch(err => console.log(err)))




// 模拟 promise.all
function promiseAll (promises) {
  return new Promise((res, rej) => {
    if(Object.prototype.toString.call(promises) !== '[object Array]') return rej('isnot array');
    let count = 0;
    let valArr = [];
    for(let i=0; i<promises.length; i++) {
      Promise.resolve(promises[i]).then(r => {
        count++;
        valArr.push(r);
        if(count === promises.length) return res(valArr);
      }).catch(r => {
        rej(r);
      })
    }
  })
}
// a = new Promise(res => setTimeout(res, 2000, 'this is a'));
// b = new Promise(res => res('b'));
// promiseAll([a, b]).then(res => {
//   console.log(res);
// })












// 观察者模式

//发布者
function Publisher(){
    this.observers = [];
    this.state = "";
}
Publisher.prototype.addOb=function(observer){
    if (!this.observers.some(ob => ob === observer)) {
      this.observers.push(observer);
    }
    return this;
}
Publisher.prototype.removeOb=function(observer){
    const i = observers.findIndex(ob => ob === observer);
    return i > -1 ? this.observers.splice(i, 1) : null;
}
Publisher.prototype.notice=function(){
    this.observers.forEach(ob => ob.update(this.state));
}
//订阅者
function Subscribe(){
    this.update = data => console.log(data);
}
//实际应用
var oba = new Subscribe(),
    obb = new Subscribe();

var pba = new Publisher();

pba.addOb(oba);
pba.addOb(obb);

oba.update = function(state){
    console.log(state+"hello!");
}
obb.update = function(state){
    console.log(state+"world!");
}
pba.state = "open ";
pba.notice();






function Event() {
    this.obs ={};
}
Event.prototype.on = function (eventType, handler) {
    if (!this.obs[eventType]) {
        this.obs[eventType] = [handler];
    } else {
        this.obs[eventType].push(handler);
    }
    return this.obs;
}
Event.prototype.emit = function (eventType) {
    if (this.obs[eventType]) {
        this.obs[eventType].forEach(ob => {
            ob.apply(this, Array.prototype.slice.call(arguments, 1));
        });
    }
}
Event.prototype.off = function (eventType, handler) {
    if (this.obs[eventType]) {
        this.obs[eventType] = this.obs[eventType].filter(ob => ob !== handler);
    }
    return this;
}


e = new Event();
cb = () => console.log(666);
e.on('test', (a) => console.log(1, a));
e.on('test', (b) => console.log(2, b));
e.on('test', cb);

e.emit('test', 'zzzz');


e.off('test', cb);

e.emit('test', 'section 2');










// 模拟 promise.race
function promiseRace(promises) {
  return new Promise((res, rej) => {
    if(Object.prototype.toString.call(promises) !== '[object Array]') return rej('isnot array');

    let curr = null;
    let val = null;

    for(let i=0; i<promises.length; i++) {
      (function(i){
        Promise.resolve(promises[i]).then(_res => {
          curr = promises[i];
          val = _res;
          return res(_res);
        }).catch(_rej => {
          rej(_rej);
        })
      })(i);
    }

  })
}


// a = new Promise(res => setTimeout(res, 1000, 'this is a'));
// b = new Promise(res => setTimeout(res, 100, 'this is b'));
// promiseRace([a, b]).then(res => console.log(res))





// 模拟 ajax
let ajax = (function () {
  
  return {
    get: function (url) {
      let xml = new XMLHttpRequest();
      return new Promise((res, rej) => {
        try {
          xml.open('GET', url, true);
          xml.send();
          xml.onreadystatechange = function () {
            if(xml.status === 200 && xml.readyState === 4) {
              res(xml.response);
            } else {
              console.log(111);
            }
          }
        } catch(err) {
          rej(err);
        }
      });
    },
    post: function (url, data) {
      let xml = new XMLHttpRequest();
      return new Promise((res, rej) => {
        try {
          xml.open('POST', url, true);
          xml.setRequestHeader('Content-Type', 'application/json');
          xml.send(data);
          xml.onreadystatechange = function () {
            if(xml.status === 200 && xml.readyState === 4) {
              res(xml.response);
            }
          }
        } catch(err) {
          rej(err);
        }
      })
    }
  }
})();
// ajax.get('http://123.207.109.197/static/img/family.76ba76b.png').then(res => console.log(res))











// 函数去抖、节流
var debounce = (function () {
  var ins = null;
  return function (fn) {
    if(ins) {
      clearTimeout(ins);
    } else {
      console.log(fn);
    }
    return ins = setTimeout(fn, 500);
  }
})();

var throttle = (function () {
  var ins = false;
  var timeStamp;
  var ctrl;
  return function (fn) {
    if(!ins) {
      fn();
      ins = true;
      timeStamp = new Date().getTime();
      ctrl = setTimeout(function () { ins = false; }, 500);
    } else {
      clearTimeout(ctrl);
      ctrl = setTimeout(function () { ins = false; }, new Date().getTime() - timeStamp);
    }
  }
})()



// 二分法

function binary(arr, num, l, r) {
  if(l > r) return;

  let mid = (l + r) >> 1;
  if(arr[mid] === num) return mid;
  
  if(arr[mid] > num) {
    return binary(arr, num, l, mid - 1);    
  } else {
    return binary(arr, num, mid + 1, r);
  }

}
// let arr = [1,5,7,9,22,66,213,632];
// console.log(binary(arr, 22, 0, arr.length-1))


// 回溯法

function backTrace(arr, res, index, temp = []) {
  if(index > arr.length) return;

  res.push(temp.slice());

  for(let i=0; i<arr.length; i++) {
    temp.push(arr[i]);
    backTrace(arr, res, index+1, temp);
    temp.pop(arr[i]);
  }
  return res;
}
let a = backTrace([1,2,3], [], 0, []);
console.log(a);


// 全排列
function fp(arr, res, index, temp = []) {

  if(arr.length === index+1) res.push(arr.slice());

  for(let i=index; i<arr.length; i++) {
    [arr[i], arr[index]] = [arr[index], arr[i]];
    fp(arr, res, index+1, temp);
    [arr[i], arr[index]] = [arr[index], arr[i]];
  }

  return res;
}

// let a = fp([1,2,3], [], 0, []);
// console.log(a);


// 快排
function quickSort(arr, l, r) {
  if(l >= r) return;

  let i = l + 1;
  let j = r;
  let num = arr[l];


  while(1) {
    while(i <= r && arr[i] < num) i++;
    while(j >= l+1 && arr[j] > num) j--;
    if(i > j) break;

    [arr[i], arr[j]] = [arr[j], arr[i]];
    i++;
    j--;

  }
  [arr[j], arr[l]] = [arr[l], arr[j]];

  quickSort(arr, l, j - 1);
  quickSort(arr, j + 1, r);

  return arr;
}

// let q = [2,3,1,5,6,3,12,43,4,32,5];
// console.time('test');
// console.log(quickSort(q, 0, q.length-1));
// console.timeEnd('test');


// 三路快排
function threeways(arr, left, right) {
  if(left > right) return;


  let num = arr[left];

  let lt = left;
  let gt = right + 1;

  let i = lt + 1;

  while(i < gt) {
    if(arr[i] < num) {
      [arr[i], arr[lt + 1]] = [arr[lt + 1], arr[i]];
      lt++;
      i++
    } else if(arr[i] > num) {
      [arr[i], arr[gt - 1]] = [arr[gt - 1], arr[i]];
      gt--;
    } else {
      i++;
    }
  }
  [arr[left], arr[lt]] = [arr[lt], arr[left]];

  threeways(arr, left, lt - 1);
  threeways(arr, gt, right);


  return arr;
}
// let q = [2,3,1,5,6,3,12,43,4,32,5];
// console.time('test');
// console.log(threeways(q, 0, q.length-1));
// console.timeEnd('test');



// 归并
function mergeSort(arr, l, r) {
  if(l >= r) return;
  let mid = (l + (r - l) >> 1);
  mergeSort(arr, l, mid);
  mergeSort(arr, mid + 1, r);
  merge(arr, l, mid, r);
}

function merge(arr, l, mid, r) {
  const res = [];
  let p1 = l, p2 = mid + 1, i = 0;

  while(p1 <= mid && p2 <= r) {
    res[i++] = arr[p1] > arr[p2] ? arr[p2++] : arr[p1++];
  }
  while(p1 <= mid) {
    res[i++] = arr[p1++];
  }
  while(p2 <= r) {
    res[i++] = arr[p2++];
  }

  res.forEach((x, j) => {
    arr[l + j] = res[j];
  })

  return arr;

}




// 寄生组合继承
function parent(name) {
  this.name = name;
  this.family = [name];
}

function son(name) {
  parent.call(this, name);

}

son.prototype = Object.create(parent.prototype);

son.prototype.constructor = son;


```



---------

