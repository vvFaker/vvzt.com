---
title: 找实习期间的学习记录（上）
date: 2018-12-12 15:15:15
categories: [技术向]
tags: [前端,实习]
---

> 这些是在找实习阶段（2018/03-2018/05）所涉及的复习点
> 有些许杂乱且不完整，勿喷


# HOLD TIGHT


## \_\_proto\_\_ & prototype 区别

!important 
> [Javascript面向对象编程（二）：构造函数的继承   -阮一峰](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html)
> [继承与原型链 -MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)

- Object.isPrototypeOf() & instanceof
- Object.getPrototypeOf()

## DOM树的遍历

- 深度优先
- 广度优先

## deepCopy 对象深拷贝 
```js
// 第一种方法、通过递归解析解决
var china = {
	nation : '中国',
	birthplaces:['北京','上海','广州'],
	skincolr :'yellow',
	friends:['sk','ls']
}
//深复制，要想达到深复制就需要用递归
function deepCopy(o,c){
var c = c || {}
for(var i in o){
	if(typeof o[i] === 'object'){
		//要考虑深复制问题了
		if(o[i].constructor === Array){
			//这是数组
			c[i] =[]
		} else{
			//这是对象
			c[i] = {}
		}
		deepCopy(o[i],c[i])
	} else{
		c[i] = o[i]
	}
   }
   return c
}
var result = {name:'result'}
result = deepCopy(china,result)
console.dir(result)


// 第二种方法：通过JSON解析解决
var test ={
	name:{
		xing:{ 
			first:'张',
			second:'李'
	},
	ming:'老头'
},
	age :40,
	friend :['隔壁老王','宋经纪','同事']
}
var result = JSON.parse(JSON.stringify(test))
result.age = 30
result.name.xing.first = '往'
result.friend.push('fdagldf;ghad')
console.dir(test)
console.dir(result)
```

## Object => toString & valueOf

- 解 => if(a==1&&a==2&&a==3) alert('pass')
- 使其成立

## 函数柯里化

- curry = a => b => a+b;  curry(1)(2) // 3

## function test() {} 和 var test = function() {} 

- 有何区别？

## 动态规划 搜索 递推

- 基本掌握

## W3C标准盒模型 & IE盒模型

- 区别/使用场景

## ES6 中的 Symbol

- 使用场景

## for in 与 for of 区别


## commonJS AMD CMD 异同

> [js模块化编程之彻底弄懂CommonJS和AMD/CMD！  -cnblogs](https://www.cnblogs.com/chenguangliang/p/5856701.html)
> [javascript模块化之CommonJS、AMD、CMD、UMD、ES6   -cnblogs](https://blog.csdn.net/Real_Bird/article/details/54869066)
> [JavaScript模块化 --- Commonjs、AMD、CMD、ES6 modules   -imooc](https://www.imooc.com/article/20057)


> [sea.js 与 requireJS 的异同  -github](https://github.com/seajs/seajs/issues/277)


## HTTP 状态码

- 100 200 201 301 302 400 500
- 301 和 302 区别
- 理解越多越好

## HTTP ？ TCP/IP ?

 > 三次握手 => C发送SNY包，S收到回复SNY+ACK，C收到并回复ACK，连接建立
 > [TCP 为什么是三次握手，而不是两次或四次？ -zhihu](https://www.zhihu.com/question/24853633)
- 基本已了解

## HTTP Option ?

- 出现在哪/作用是什么

## 从访问一个网站到显示完毕发生了什么？

- 越详细越好
- 简略版：
1. 输入域名后，由DNS解析出IP
2. 获得IP地址，建立TCP连接、发送HTTP请求
3. 服务器收到数据，处理请求并返回对应的内容，同样以HTTP报文形式返回给客户端
4. 客户端拿到数据，构建DOM树，渲染页面，同时异步加载CSS JS 等外部资源

- 补充：从浏览器发出请求后，可按照OSI七层模型或TCP模型依次每层解释，重点说清三次握手/四次挥手部分，越详细越好，包括浏览器渲染流程、缓存机制、安全方面、Cookie&Session等等都可以说

## 元素的 absolute 是相对谁而言的

- 相对于 上级元素中 第一个position为非Static的元素 而言
- 如果都是static 那么相对于window定位

## XSS & CSRF

- 原理及预防
- 之前玩过XSS，可以引申


- CSRF
0. 加验证码，但影响用户体验
1. 验证 HTTP Referer 字段，不太可靠
2. 在请求地址中添加 token 并验证
3. 在 HTTP 头中自定义属性并验证


## GET & POST 区别

- GET 有长度限制，且对用户可见
- GET 可被缓存， POST 不可以
- 语义上区别：GET 获取数据  POST 提交数据
- 相对来说 POST 比 GET 更安全
- POST 支持如 form-data 二进制报文格式


## 上传文件为什么要设置MIME 为 multipart/form-data

> multipart/form-data C向S发送二进制数据

> [MIME 类型  -MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types)


## RESTful API

- 如何定义
- 个人理解


## UTF-8 与 GBK 的区别？

- UTF-8 英文使用1个字节编码 中文3个字节
- GBK 中英文均为2个字节
- UTF-8各国通用，GBK国内标准，国外访问需要下载语言包

## 函数节流 & 防抖

- 用途
- 实现
- 手写代码（简易版即可）

## 如何解决跨域问题 前端&后端

- 前端 [「JavaScript」JS四种跨域方式详解](https://segmentfault.com/a/1190000003642057)
 1. JSONP
 2. postMessage
 3. document.domain
 4. window.name
- 后端 [「JavaScript」JS两种服务端相关跨域方法详解](https://segmentfault.com/a/1190000003693381)
 1. CORS
 2. 反向代理

## Vue 生命周期

- beforeCreate
- created
- beforeMount
- mounted
- beforeUpdate
- updated
- beforeDestroy
- destroyed

> [Vue 实例中的生命周期钩子详解  -github](https://github.com/koucxz/blog/issues/3)

## Vue.js diff 算法

> [解析vue2.0的diff算法  -segmentfault](https://segmentfault.com/a/1190000008782928)

## Vue-Router 原理

> [深入Vue-Router源码分析路由实现原理  -cnblogs](https://blog.csdn.net/u013938465/article/details/79421239)

> [vue-router源码分析-整体流程 -github](https://github.com/DDFE/DDFE-blog/issues/9)

## 虚拟 DOM

> [如何理解虚拟DOM？ -zhihu](https://www.zhihu.com/question/29504639)

## Webpack 热更新原理

> [Webpack 热更新实现原理分析  -zhihu](https://zhuanlan.zhihu.com/p/30623057)


## 数据双向绑定的实现

- 目前基于 Object.definePropoertiesy
- Vue 3.0 中改用 Proxy，了解 Proxy 与 Object.defineProperty 区别优缺点


## 设计模式

- 单例模式
- 观察者模式
- 发布/订阅模式
- 策略模式
- 工厂模式
- ...

> 单例、发布订阅、观察者 了解并手写

## setTimeout("test()", 1000) 与 setTimeout(test(), 1000) & setTimeout(test, 1000) 的区别

> "test()" 作用域为全局且1秒后执行
> test() 为当前作用域且立即执行
> test 为1秒后执行


## Promise

- 用法 & 优缺点 & 原理

- 原生js模拟实现Promise
- 原生js模拟实现Promise.all
- 原生js模拟实现Promise.race

> [实现promise  -segmentfault](https://segmentfault.com/a/1190000014218384)

> [剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类  -Github](https://github.com/xieranmaya/blog/issues/3)


## 原生JS模拟实现call & apply

- 手写，熟练掌握

## 判断一个变量是否为 Array

- 有多少种方法 & 优缺点
- Object.prototype.toString.call(arr) === '[object Array]'

## JS中如何正确判断数组是数组

> [在JavaScript中，如何判断数组是数组？  -segmentfault](https://segmentfault.com/a/1190000006150186)

> [javascript类型系统——undefined和null  -cnblogs](https://www.cnblogs.com/xiaohuochai/p/5665637.html)!important

## async / await

- 理解&熟练使用
- 可引申到 Generator ，还有 express（使用Generator） 与 Koa（使用Async/Await）

> [理解 JavaScript 的 async/await  -segmentfault](https://segmentfault.com/a/1190000007535316)

## 三种查找算法

- 分块的平均查找长度
- ...



## scroll offset client 区别



## LRU LFU FIFO 页面置换算法

- LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!
- LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!



## 写一个TODO List

> 设计一个TODO List，页面结构如下图所示，要求：
使用HTML与CSS完成界面开发
实现添加功能：输入框中可输入任意字符，按回车后将输入字符串添加到下方列表的最后，并清空输入框
实现删除功能：点击列表项后面的“X”号，可以删除该项
实现模糊匹配：在输入框中输入字符后，将当前输入字符串与已添加的列表项进行模糊匹配，将匹配到的结果显示在输入框下方。如匹配不到任何列表项，列表显示空




## getElement & querySelector 的区别

> getElement 获取的是动态集合，每次对其操作都会重新查询DOM并修改，DOM改变也会随之改变
> querySelector 获取的是静态集合，每次修改不会再次查询，并且不会随DOM的改变而改变


## 图片懒加载实现

- js控制img加载
- 用 getBoundingClientRect() 获取元素距浏览器视窗位置


## 如果一个ul里面插入1000个li节点，怎么插入？

- 个人感觉，考虑到性能，可以使用 createDocumentFragment() 暂存用 createElement() 创建的所有li节点，再一次插入，减少重流，使用字符串拼接及 innerHTML 同理。
- 使用 requestAnimationFrame
- 配合上面的方法进行分时插入（可以使页面不卡顿）

## 浏览器渲染流程

- 可由此引申到性能优化

> [浏览器渲染流程  -imooc](https://www.imooc.com/article/23484?block_id=tuijian_wz)


## client offset scroll 区别


## p 元素里能不能嵌套 div ？ a 是块元素还是行内


## 块级 & 行内

## 获取 HTMLCollection(s) or Node(List)

- getElement
- querySelector


## DOM 操作

- body.children
- body.firstElementChild
- body.nextElementSibling
- body.append
- body.remove


- body.childNodes
- body.firstChild
- body.nextSibling
- body.insertBefore
- body.appendChild
- body.removeChild




## BFC 特点？ 触发条件？

- BFC布局规则：

1. 内部的Box会在垂直方向，一个接一个地放置。
2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4. BFC的区域不会与float box重叠。
5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6. 计算BFC的高度时，浮动元素也参与计算

- 触发BFC的方式（以下任意一条就可以）
0. 是根元素
1. float 不为 none
2. overflow 不为 visible
3. position 为 absolute 或 fixed
4. display 为 flex, inline-flex, table-cell, tabble-caption, inline-block


## 编写web端cookie的设置和获取方法



## 手写parseInt的实现



## 实现页面加载进度条



## CSS 优先级

> [CSS 样式优先级  -segmentfault](https://segmentfault.com/a/1190000003860309)

!important > inline > id > class=class[xx='xxx']=xxx:hover > tagName=xxx::after
> 优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器



## UTF-8 与 UTF-8 BOM 区别

- BOM ？

> [BOM](https://en.wikipedia.org/wiki/Byte_order_mark)


## DOMRect

- el.getClientRects()


## link visited hover active 放置的顺序？为什么？
- a:link
- a:visited
- a:hover
- a:active

## TCP/IP 为什么要 3 次握手 4 次挥手

- 三次握手


## UDP 与 TCP 报文

- 区别
- 特点


## session 与 token 的区别

均为身份验证
- session => 空间换时间
- token => 时间换空间


>  在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”而是“两次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。说白了主要目的是防止server端一直等待，浪费资源。

- 四次挥手

> 和TCP三次同步握手不一样的是，TCP关闭连接用四次握手来实现，即A--->B Fin, B--->A ACK, B--->A Fin, A--->B ACK，为什么要这样？

> A--->B Fin, B--->A ACK ，A属于主动关闭方，收到B的ACK后，A到B的方向连接关闭，即half shutown ，这时A不能再发送数据了。

> 这种状态下B还是可以单向发送数据的，B的数据发送完毕，也做关闭动作了：
B--->A Fin, A--->B ACK

> B收到ACK，关闭连接。但是A无法知道ACK是否已经到达B，于是开始等待？等待什么呢？假如ACK没有到达B，B会为FIN这个消息超时重传 timeout retransmit ，那如果A等待时间足够，又收到FIN消息，说明ACK没有到达B，于是再发送ACK，直到在足够的时间内没有收到FIN，说明ACK成功到达。这个等待时间至少是：B的timeout + FIN的传输时间，为了保证可靠，采用更加保守的等待时间2MSL。
MSL，Maximum Segment Life，这是TCP 对TCP Segment 生存时间的限制。

> TTL， Time To Live ，IP对IP Datagram 生存时间的限制，255 秒，所以 MSL一般 = TTL = 255秒
A发出ACK，等待ACK到达对方的超时时间 
MSL，等待FIN的超时重传，也是MSL，所以如果2MSL时间内没有收到FIN，说明对方安全收到FIN。
综上所述，等待2MSL的目的是为了A最后发送的ACK能最终到达B端。




## TCP/IP 中的 TIME_WAIT 状态
- 为什么有 TIME_WAIT
- 为什么要等待 2MSL


--------

***未完待续，请看下集...***